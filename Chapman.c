#pragma config(Sensor, in8,    LiftP,          sensorPotentiometer)
#pragma config(Sensor, dgtl5,  TR,             sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  TL,             sensorQuadEncoder)
#pragma config(Motor,  port1,           topLeft,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           topRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftLiftMD,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightLiftMD,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftLiftU,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightLiftU,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftclaw,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightclaw,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           bottomLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          bottomRight,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

static const int LIFT_UP_VELOCITY = 127;
static const int LIFT_DOWN_VELOCITY = -127;
static const int NONE_CONST = 0;
static const int SINGLE_STAR_CONST = -15;
static const int FULL_POWER = 127;
bool deltaApply;
bool claw;

//Converts distance needed to travel from centimeters to the counts from the encoders
long calculate (long distancetraveled){
	long radius = (2.75/2)*2.54;
	long circumference = radius*2*PI;
	long encoderCounts = (360/circumference)*distancetraveled;
	return encoderCounts;
}

//Moving Forward

void forwardstraight(long encoderCounts, long sec, bool claw){


		SensorValue[TR] = 0;
		SensorValue[TL] = 0;
		motor[leftclaw] = 0;
		motor[rightclaw] = 0;



	while(SensorValue[TR]*cos(45)*2.54 <= encoderCounts && abs(SensorValue[TL])*cos(45)*2.54 <= encoderCounts
		){
		motor[topRight] = FULL_POWER;
		motor[topLeft] =  FULL_POWER;
		motor[bottomRight]= FULL_POWER;
		motor[bottomLeft] = FULL_POWER;

		if(claw == true)
	{
			motor[leftclaw] = -FULL_POWER;
			motor[rightclaw] = -FULL_POWER;
			wait1Msec(sec*1000);
		}
	}

	motor[topRight] = 0;
	motor[topLeft] =  0;
	motor[bottomRight]= 0;
	motor[bottomLeft] = 0;
	motor[leftclaw] = 0;
	motor[rightclaw] = 0;


}

//Moving Backwards

void backwardstraight(long encoderCounts, bool lift2){

	if(lift2 == false){
		SensorValue[TR] = 0;
		SensorValue[TL] = 0;
		motor[leftclaw] = 0;
		motor[rightclaw] = 0;
	}

	while(SensorValue[TR]*cos(45)*2.54 <= encoderCounts && abs(SensorValue[TL])*cos(45)*2.54 <= encoderCounts
		){
		motor[topRight] = -FULL_POWER;
		motor[topLeft] =  -FULL_POWER;
		motor[bottomRight]= -FULL_POWER;
		motor[bottomLeft] = -FULL_POWER;

	}
	motor[topRight] = 0;
	motor[topLeft] =  0;
	motor[bottomRight]= 0;
	motor[bottomLeft] = 0;
}



//Right

void right(long encoderCounts){

	SensorValue[TR] = 0;
	SensorValue[TL] = 0;

	motor[leftclaw] = 0;
	motor[rightclaw] = 0;

	while(SensorValue[TR]*cos(45)*2.54 <= encoderCounts && abs(SensorValue[TL])*cos(45)*2.54 <= encoderCounts
		){
		motor[topRight] = -FULL_POWER;
		motor[topLeft] =  FULL_POWER;
		motor[bottomRight]= FULL_POWER;
		motor[bottomLeft] = -FULL_POWER;

	}
	motor[topRight] = 0;
	motor[topLeft] =  0;
	motor[bottomRight]= 0;
	motor[bottomLeft] = 0;


}

//Turning Left

void turnL(long encoderCounts){


	SensorValue[TR] = 0;
	SensorValue[TL] = 0;

	while (SensorValue[TR]*cos(45)*2.54 <= encoderCounts && abs(SensorValue[TL])*cos(45)*2.54 <= encoderCounts
		){
		motor[topRight] = FULL_POWER;
		motor[topLeft] =  -FULL_POWER;
		motor[bottomRight]= FULL_POWER;
		motor[bottomLeft] = -FULL_POWER;


	}
	motor[topRight] = 0;
	motor[topLeft] =  0;
	motor[bottomRight]= 0;
	motor[bottomLeft] = 0;


}

//Turning Right

void turnR(long encoderCounts){

	SensorValue[TR] = 0;
	SensorValue[TL] = 0;

	while (SensorValue[TR]*cos(45)*2.54 <= encoderCounts && abs(SensorValue[TL])*cos(45)*2.54 <= encoderCounts
		){
		motor[topRight] = -FULL_POWER;
		motor[topLeft] =  FULL_POWER;
		motor[bottomRight]= -FULL_POWER;
		motor[bottomLeft] = FULL_POWER;

	}

	motor[topRight] = 0;
	motor[topLeft] =  0;
	motor[bottomRight]= 0;
	motor[bottomLeft] = 0;
}

void clawGrab(long sec){
	motor[leftclaw] = -FULL_POWER;
	motor[rightclaw] = -FULL_POWER;
	wait1Msec(sec*1000);

}

void clawOpen(long sec){

	motor[leftclaw] = FULL_POWER;
	motor[rightclaw] = FULL_POWER;
	wait1Msec(sec*1000);

}

void SLift(){

	while(SensorValue[LiftP] < 500){
		motor[leftLiftMD] = LIFT_UP_VELOCITY;
		motor[leftLiftU] = LIFT_UP_VELOCITY;
		motor[rightLiftMD] = LIFT_UP_VELOCITY;
		motor[rightLiftU] = LIFT_UP_VELOCITY;
	}
	motor[leftLiftMD] = 0;
	motor[leftLiftU] = 0;
	motor[rightLiftMD] = 0;
	motor[rightLiftU] = 0;
}

void throw(bool move, long distance){
	if(move){

		long x = distance;

		SensorValue[TR] = 0;
		SensorValue[TL] = 0;

		while((SensorValue[TR]*cos(45)*2.54 <= calculate(x) && abs(SensorValue[TL])*cos(45)*2.54 <= calculate(x)) || SensorValue[LiftP] < 2500) {
			if(SensorValue[TR]*cos(45)*2.54 <= calculate(x) && abs(SensorValue[TL])*cos(45)*2.54 <= calculate(x)
				) {
				motor[topRight] = -FULL_POWER;
				motor[topLeft] =  -FULL_POWER;
				motor[bottomRight]= -FULL_POWER;
				motor[bottomLeft] = -FULL_POWER;
			}
			else{
				motor[topRight] = 0;
				motor[topLeft] =  0;
				motor[bottomRight]= 0;
				motor[bottomLeft] = 0;

			}

			if(SensorValue[LiftP] < 2400){
				motor[leftLiftMD] = LIFT_UP_VELOCITY;
				motor[leftLiftU] = LIFT_UP_VELOCITY;
				motor[rightLiftMD] = LIFT_UP_VELOCITY;
				motor[rightLiftU] = LIFT_UP_VELOCITY;

				if(SensorValue[LiftP] > 2200){
					motor[leftclaw] = FULL_POWER;
					motor[rightclaw] = FULL_POWER;
				}
			}


			if(SensorValue[LiftP] > 2500){
				motor[leftLiftMD] = 0;
				motor[leftLiftU] = 0;
				motor[rightLiftMD] = 0;
				motor[rightLiftU] = 0;
			}

			while(SensorValue[TR]*cos(45)*2.54 <= calculate(x-10) && abs(SensorValue[TL])*cos(45)*2.54 <= calculate(x-10)){
				if(SensorValue[LiftP] < 2400){
					motor[leftLiftMD] = LIFT_UP_VELOCITY;
					motor[leftLiftU] = LIFT_UP_VELOCITY;
					motor[rightLiftMD] = LIFT_UP_VELOCITY;
					motor[rightLiftU] = LIFT_UP_VELOCITY;
					if(SensorValue[LiftP] > 2200){
						motor[leftclaw] = FULL_POWER;
						motor[rightclaw] = FULL_POWER;
					}
				}


				if(SensorValue[LiftP] > 2500){
					motor[leftLiftMD] = 0;
					motor[leftLiftU] = 0;
					motor[rightLiftMD] = 0;
					motor[rightLiftU] = 0;
				}

				if(SensorValue[TR]*cos(45)*2.54 <= calculate(x) && abs(SensorValue[TL])*cos(45)*2.54 <= calculate(x)
					) {
					motor[topRight] = -FULL_POWER;
					motor[topLeft] =  -FULL_POWER;
					motor[bottomRight]= -FULL_POWER;
					motor[bottomLeft] = -FULL_POWER;
				}
			}
		}
		motor[leftLiftMD] = 0;
		motor[leftLiftU] = 0;
		motor[rightLiftMD] = 0;
		motor[rightLiftU] = 0;
		motor[rightclaw] = 0;
		motor[leftclaw] = 0;
		motor[topRight] = 0;
		motor[topLeft] =  0;
		motor[bottomRight]= 0;
		motor[bottomLeft] = 0;

	}
	else if(move == false){

		SensorValue[TR] = 0;
		SensorValue[TL] = 0;

		while(SensorValue[LiftP] < 2500) {
			if(SensorValue[LiftP] < 2500){  //2520
				motor[leftLiftMD] = LIFT_UP_VELOCITY;
				motor[leftLiftU] = LIFT_UP_VELOCITY;
				motor[rightLiftMD] = LIFT_UP_VELOCITY;
				motor[rightLiftU] = LIFT_UP_VELOCITY;
				if(SensorValue[LiftP] > 2300 && SensorValue[LiftP] < 2500){
					clawOpen(0.2);
				}
			}
			else{
				motor[leftLiftMD] = 0;
				motor[leftLiftU] = 0;
				motor[rightLiftMD] = 0;
				motor[rightLiftU] = 0;
			}
		}
		motor[leftLiftMD] = 0;
		motor[leftLiftU] = 0;
		motor[rightLiftMD] = 0;
		motor[rightLiftU] = 0;
		motor[rightclaw] = 0;
		motor[leftclaw] = 0;
	}

	/////////////////////////////////////////////////////////

}

void LiftDown(bool move2, long distance2){
	if(move2){

		long x = distance2;

		SensorValue[TR] = 0;
		SensorValue[TL] = 0;

		while((SensorValue[TR]*cos(45)*2.54 <= calculate(x) && abs(SensorValue[TL])*cos(45)*2.54 <= calculate(x)) || SensorValue[LiftP] > 200) {
			if(SensorValue[TR]*cos(45)*2.54 <= calculate(x) && abs(SensorValue[TL])*cos(45)*2.54 <= calculate(x)
				) {
				motor[topRight] = FULL_POWER;
				motor[topLeft] =  FULL_POWER;
				motor[bottomRight]= FULL_POWER;
				motor[bottomLeft] = FULL_POWER;
			}
			else{
				motor[topRight] = 0;
				motor[topLeft] =  0;
				motor[bottomRight]= 0;
				motor[bottomLeft] = 0;

			}

			if(SensorValue[LiftP] > 200){
				motor[leftLiftMD] = LIFT_DOWN_VELOCITY;
				motor[leftLiftU] = LIFT_DOWN_VELOCITY;
				motor[rightLiftMD] = LIFT_DOWN_VELOCITY;
				motor[rightLiftU] = LIFT_DOWN_VELOCITY;

			}


			if(SensorValue[LiftP] < 200){
				motor[leftLiftMD] = 0;
				motor[leftLiftU] = 0;
				motor[rightLiftMD] = 0;
				motor[rightLiftU] = 0;
			}

			while(SensorValue[TR]*cos(45)*2.54 <= calculate(x-10) && abs(SensorValue[TL])*cos(45)*2.54 <= calculate(x-10)){
				if(SensorValue[LiftP] > 200){
					motor[leftLiftMD] = LIFT_DOWN_VELOCITY;
					motor[leftLiftU] = LIFT_DOWN_VELOCITY;
					motor[rightLiftMD] = LIFT_DOWN_VELOCITY;
					motor[rightLiftU] = LIFT_DOWN_VELOCITY;
				}


				if(SensorValue[LiftP] < 200){
					motor[leftLiftMD] = 0;
					motor[leftLiftU] = 0;
					motor[rightLiftMD] = 0;
					motor[rightLiftU] = 0;
				}

				if(SensorValue[TR]*cos(45)*2.54 <= calculate(x) && abs(SensorValue[TL])*cos(45)*2.54 <= calculate(x)
					) {
					motor[topRight] = FULL_POWER;
					motor[topLeft] =  FULL_POWER;
					motor[bottomRight]= FULL_POWER;
					motor[bottomLeft] = FULL_POWER;
				}
			}
		}
		motor[leftLiftMD] = 0;
		motor[leftLiftU] = 0;
		motor[rightLiftMD] = 0;
		motor[rightLiftU] = 0;
		motor[rightclaw] = 0;
		motor[leftclaw] = 0;
		motor[topRight] = 0;
		motor[topLeft] =  0;
		motor[bottomRight]= 0;
		motor[bottomLeft] = 0;

	}

	else if(move2 == false){

		SensorValue[TR] = 0;
		SensorValue[TL] = 0;

		while(SensorValue[LiftP] > 120) {
			if(SensorValue[LiftP] > 120){
				motor[leftLiftMD] = LIFT_DOWN_VELOCITY;
				motor[leftLiftU] = LIFT_DOWN_VELOCITY;
				motor[rightLiftMD] = LIFT_DOWN_VELOCITY;
				motor[rightLiftU] = LIFT_DOWN_VELOCITY;
			}
			else{
				motor[leftLiftMD] = 0;
				motor[leftLiftU] = 0;
				motor[rightLiftMD] = 0;
				motor[rightLiftU] = 0;
			}
		}
		motor[leftLiftMD] = 0;
		motor[leftLiftU] = 0;
		motor[rightLiftMD] = 0;
		motor[rightLiftU] = 0;
	}

	/////////////////////////////////////////////////////////////

}
void pre_auton() {
	bStopTasksBetweenModes = true;
}

task autonomous() {

	//Starting on the right side of the field

	//throw(true,90);

	clawGrab(0.5);

	wait1Msec(500);

	forwardstraight(calculate(57), 0.2, false); //Subtract 10cm to take account for momentum

  turnL(calculate(38));

	forwardstraight(calculate(43),  1, false);

	clawGrab(0.5);

	wait1Msec(1*1000);

	SLift();

	forwardstraight(calculate(10), 1 , false);

	motor[leftLiftMD] = -SINGLE_STAR_CONST;
	motor[leftLiftU] =  -SINGLE_STAR_CONST;
	motor[rightLiftMD]= -SINGLE_STAR_CONST;
	motor[rightLiftMD] = -SINGLE_STAR_CONST;

	turnL(calculate(35));


	motor[leftLiftMD] = 0;
	motor[leftLiftU] =  0;
	motor[rightLiftMD]= 0;
	motor[rightLiftMD] = 0;

	throw(true, 65);

	motor[leftclaw] = 0;
	motor[rightclaw] = 0;

	forwardstraight(calculate(10),  1, false);

	LiftDown(true, 50);

	clawOpen(0.5);

	wait1Msec(0.1 * 1000);

	forwardstraight(calculate(30), 1, false);

	clawGrab(0.5);

	wait1Msec(1*1000);

	SLift();

	throw(true, 80);

}

void driveCode();

task usercontrol() {
	while (true) {

		/*if(vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0){
		//	motor[leftLiftMD] = -SINGLE_STAR_CONST;
		//motor[leftLiftU] =  -SINGLE_STAR_CONST;
		//motor[rightLiftMD]= -SINGLE_STAR_CONST;
		//motor[rightLiftMD] = -SINGLE_STAR_CONST;

		if (vexRT[Btn6U] == 1) {
		motor[leftclaw] = FULL_POWER;
		motor[rightclaw] = FULL_POWER;
		} else if (vexRT[Btn6D] == 1) {
		motor[leftclaw] = -FULL_POWER;                                      // PURGE THIS SHIT PLEASE I BEG YOU
		motor[rightclaw] = -FULL_POWER;
		} else {
		motor[leftclaw] = 0;
		motor[rightclaw] = 0;
		}
		driveCode();
		}
		else {*/



		/*      FUCKING CLAW STUFF BECAUSE COMMENTS      */

		// IF KENSHINMAGIC 1 == true?????
		if (vexRT[Btn5U] == 1 && !vexRT[Btn5D] == 1) {
			motor[leftLiftMD] = LIFT_UP_VELOCITY;
			motor[leftLiftU] = LIFT_UP_VELOCITY;
			motor[rightLiftMD] = LIFT_UP_VELOCITY;
			motor[rightLiftU] = LIFT_UP_VELOCITY;
		}

		// IF SOMETHINGCRYPTIC
		else if (vexRT[Btn5D] == 1 && SensorValue[LiftP] > 120 && !vexRT[Btn5U] == 1) {
			motor[leftLiftMD] = LIFT_DOWN_VELOCITY;
			motor[leftLiftU] = LIFT_DOWN_VELOCITY;
			motor[rightLiftMD] = LIFT_DOWN_VELOCITY;
			motor[rightLiftU] = LIFT_DOWN_VELOCITY;
		}

		//IF THE GAYS ARE GAY
		else if (!vexRT[Btn5U] == 1 && !vexRT[Btn5D] == 1) {
			motor[leftLiftMD] = 0;
			motor[leftLiftU] = 0;
			motor[rightLiftMD] = 0;
			motor[rightLiftU] = 0;
		}


		// IF SOME MAGIC THROW BUTTON IS PRESSED APPROXIMATELY 3 MICRONS DOWN, THE STARS ARE ALIGNED AS WHEN JESUS WAS BORN, MY DICK IS 3 INCHES, AND KENSHIN DOESN'T COMMENT HIS CODE
		if (vexRT[Btn8L] == 1) {

			throw(false, 1);

		}


		///////////////////// A BUNCH OF SLASHES TO SHOW WHAT THEY'RE USED FOR
		if (vexRT[Btn6U] == 1 && !vexRT[Btn6D] == 1) {
			motor[leftclaw] = 70;
			motor[rightclaw] = 70;
			//	claw = true;
		}
		// SEND A MISSLE TO MARS, ACCURATE
		else if (vexRT[Btn6D] == 1 && !vexRT[Btn6U] == 1) {
			motor[leftclaw] = -70;
			motor[rightclaw] = -70;
			//	claw = false;
		}
		// IF ?????????????????? THEN ?!?!?!?!?!??!?!?!??!
		else {
			motor[leftclaw] = 0;
			motor[rightclaw] = 0;
			/*if(claw == true){
			motor[leftclaw] = -30;
			motor[rightclaw] = -30;                      /// PURGE THESE LIKE THE PLAGUE

			}*/


		}
		driveCode();
	}
}

void driveCode () {

	motor[topRight] = vexRT[Ch3] -vexRT[Ch1] -vexRT[Ch4];//RFM = Right Front Motor      // don't use acronyms people won't immediately know, and what does the line do? that's what the comment is for <3
	motor[topLeft] = vexRT[Ch3] +vexRT[Ch1] +vexRT[Ch4];//LFM = Left Front Motor
	motor[bottomRight] = vexRT[Ch3] -vexRT[Ch1] +vexRT[Ch4];//RBM = Right Back Motor
	motor[bottomLeft] = vexRT[Ch3] + vexRT[Ch1] -vexRT[Ch4];//LBM = Left Back Motor

}
