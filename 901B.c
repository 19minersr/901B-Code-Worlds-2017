#pragma config(Sensor, in1,    LiftP,          sensorPotentiometer)
#pragma config(Sensor, dgtl5,  TR,             sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  TL,             sensorQuadEncoder)
#pragma config(Motor,  port1,           topLeft,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           topRight,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           leftLiftMD,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           rightLiftMD,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           leftLiftU,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightLiftU,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           leftclaw,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           rightclaw,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           bottomLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          bottomRight,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
static const int LIFT_UP_VELOCITY = 127;
static const int LIFT_DOWN_VELOCITY = -127;
static const int NONE_CONST = 0;
static const int SINGLE_STAR_CONST = -15;
static const int FULL_POWER = 127;
bool deltaApply;

//Converts distance needed to travel from centimeters to the counts from the encoders
long calculate (long distancetraveled){
	long radius = (2.75/2)*2.54;
	long circumference = radius*2*PI;
	long encoderCounts = (360/circumference)*distancetraveled;
	return encoderCounts;
}
//Moving Forward

void forwardstraight(long encoderCounts){
	SensorValue[TR] = 0;
	SensorValue[TL] = 0;

	while (SensorValue[TR]*cos(45)*2.54 <= encoderCounts && abs(SensorValue[TL])*cos(45)*2.54 <= encoderCounts
		){
		motor[topRight] = FULL_POWER;
		motor[topLeft] =  FULL_POWER;
		motor[bottomRight]= FULL_POWER;
		motor[bottomLeft] = FULL_POWER;
	}
	motor[topRight] = 0;
	motor[topLeft] =  0;
	motor[bottomRight]= 0;
	motor[bottomLeft] = 0;

}

//Moving Backwards
void backwardstraight(long encoderCounts){

	SensorValue[TR] = 0;
	SensorValue[TL] = 0;
	while (SensorValue[TR]*cos(45)*2.54 <= encoderCounts && abs(SensorValue[TL])*cos(45)*2.54 <= encoderCounts
		){
		motor[topRight] = -FULL_POWER;
		motor[topLeft] =  -FULL_POWER;
		motor[bottomRight]= -FULL_POWER;
		motor[bottomLeft] = -FULL_POWER;

	}
	motor[topRight] = 0;
	motor[topLeft] =  0;
	motor[bottomRight]= 0;
	motor[bottomLeft] = 0;
}
//Turning Left

void turnL(long encoderCounts){

	SensorValue[TR] = 0;
	SensorValue[TL] = 0;
	while (SensorValue[TR]*cos(45)*2.54 <= encoderCounts && abs(SensorValue[TL]*cos(45)*2.54) <= encoderCounts
		){
		motor[topRight] = FULL_POWER;
		motor[topLeft] =  -FULL_POWER;
		motor[bottomRight]= FULL_POWER;
		motor[bottomLeft] = -FULL_POWER;

	}
	motor[topRight] = 0;
	motor[topLeft] =  0;
	motor[bottomRight]= 0;
	motor[bottomLeft] = 0;

}

//Turning Right
void turnR(long encoderCounts){

	SensorValue[TR] = 0;
	SensorValue[TL] = 0;
	while (SensorValue[TR]*cos(45)*2.54 <= encoderCounts && SensorValue[TL]*cos(45)*2.54 <= -encoderCounts
		){
		motor[topRight] = -FULL_POWER;
		motor[topLeft] =  FULL_POWER;
		motor[bottomRight]= -FULL_POWER;
		motor[bottomLeft] = FULL_POWER;

	}
	motor[topRight] = 0;
	motor[topLeft] =  0;
	motor[bottomRight]= 0;
	motor[bottomLeft] = 0;
}

void clawGrab(long sec){
	motor[leftclaw] = FULL_POWER;
	motor[rightclaw] = FULL_POWER;
	wait1Msec(sec*1000);

}
void clawOpen(long sec){

	motor[leftclaw] = -FULL_POWER;
	motor[rightclaw] = -FULL_POWER;
	wait1Msec(sec*1000);
}

void throw(bool move){
	if(move){
		motor[leftLiftMD] = LIFT_UP_VELOCITY;
		motor[leftLiftU] = LIFT_UP_VELOCITY;
		motor[rightLiftMD] = LIFT_UP_VELOCITY;
		motor[rightLiftU] = LIFT_UP_VELOCITY;
		wait1Msec(1600);
		motor[leftLiftMD] = 0;
		motor[leftLiftU] = 0;
		motor[rightLiftMD] = 0;
		motor[rightLiftU] = 0;
		motor[leftclaw] = -FULL_POWER;
		motor[rightclaw] = -FULL_POWER;
		wait1Msec(500);
		motor[leftclaw] = 0;
		motor[rightclaw] = 0;
		motor[leftLiftMD] = LIFT_DOWN_VELOCITY;
		motor[leftLiftU] = LIFT_DOWN_VELOCITY;
		motor[rightLiftMD] = LIFT_DOWN_VELOCITY;
		motor[rightLiftU] = LIFT_DOWN_VELOCITY;
		wait1Msec(1600);
		motor[leftLiftMD] = 0;
		motor[leftLiftU] = 0;
		motor[rightLiftMD] = 0;
		motor[rightLiftU] = 0;
	}
	else if(move == false){
		motor[leftLiftMD] = LIFT_UP_VELOCITY;
		motor[leftLiftU] = LIFT_UP_VELOCITY;
		motor[rightLiftMD] = LIFT_UP_VELOCITY;
		motor[rightLiftU] = LIFT_UP_VELOCITY;
		wait1Msec(1600);
		motor[leftLiftMD] = 0;
		motor[leftLiftU] = 0;
		motor[rightLiftMD] = 0;
		motor[rightLiftU] = 0;
		motor[leftclaw] = -FULL_POWER;
		motor[rightclaw] = -FULL_POWER;
		wait1Msec(500);
		motor[leftclaw] = 0;
		motor[rightclaw] = 0;
		motor[leftLiftMD] = LIFT_DOWN_VELOCITY;
		motor[leftLiftU] = LIFT_DOWN_VELOCITY;
		motor[rightLiftMD] = LIFT_DOWN_VELOCITY;
		motor[rightLiftU] = LIFT_DOWN_VELOCITY;
		wait1Msec(1600);
		motor[leftLiftMD] = 0;
		motor[leftLiftU] = 0;
		motor[rightLiftMD] = 0;
		motor[rightLiftU] = 0;
	}
}

void pre_auton() {
	bStopTasksBetweenModes = true;
}

task autonomous() {
	/*clawOpen(1);
	forwardstraight(calculate(180)); //Subtract 20cm to take account for momentum
	wait1Msec(250);
	turnL(calculate(50));
	clawGrab(1);
	backwardstraight(calculate(100));*/
	turnL(calculate(33));
	wait1Msec(500);
	turnR(calculate(33));
	//forwardstraight(50);
	//throw(true);


}

void driveCode();
task usercontrol() {
	while (true) {

		if(vexRT[Btn5U] == 0 && vexRT[Btn5D] == 0){
			motor[leftLiftMD] = -SINGLE_STAR_CONST;
			motor[leftLiftU] =  -SINGLE_STAR_CONST;
			motor[rightLiftMD]= -SINGLE_STAR_CONST;
			motor[rightLiftMD] = -SINGLE_STAR_CONST;
			if (vexRT[Btn6U] == 1) {
				motor[leftclaw] = FULL_POWER;
				motor[rightclaw] = FULL_POWER;
				} else if (vexRT[Btn6D] == 1) {
				motor[leftclaw] = -FULL_POWER;
				motor[rightclaw] = -FULL_POWER;
				} else {
				motor[leftclaw] = 0;
				motor[rightclaw] = 0;
			}
			driveCode();
		}
		else {

			if (vexRT[Btn5U] == 1) {
				motor[leftLiftMD] = LIFT_UP_VELOCITY;
				motor[leftLiftU] = LIFT_UP_VELOCITY;
				motor[rightLiftMD] = LIFT_UP_VELOCITY;
				motor[rightLiftU] = LIFT_UP_VELOCITY;
				} else if (vexRT[Btn5D] == 1) {
				motor[leftLiftMD] = LIFT_DOWN_VELOCITY;
				motor[leftLiftU] = LIFT_DOWN_VELOCITY;
				motor[rightLiftMD] = LIFT_DOWN_VELOCITY;
				motor[rightLiftU] = LIFT_DOWN_VELOCITY;
				} else {
				motor[leftLiftMD] = 0;
				motor[leftLiftU] = 0;
				motor[rightLiftMD] = 0;
				motor[rightLiftU] = 0;
			}

			if (vexRT[Btn8L] == 1) {
				throw(false);

			}
			if (vexRT[Btn6D] == 1) {
				motor[leftclaw] = -FULL_POWER;
				motor[rightclaw] = -FULL_POWER;
				} else if (vexRT[Btn6U] == 1) {
				motor[leftclaw] = FULL_POWER;
				motor[rightclaw] = FULL_POWER;
				} else {
				motor[leftclaw] = 0;
				motor[rightclaw] = 0;
			}
		}
		driveCode();
	}
}
void driveCode () {

	motor[topRight] = vexRT[Ch3] +vexRT[Ch1] -vexRT[Ch4];//RFM = Right Front Motor
	motor[topLeft] = vexRT[Ch3] -vexRT[Ch1] +vexRT[Ch4];//LFM = Left Front Motor
	motor[bottomRight] = vexRT[Ch3] +vexRT[Ch1] +vexRT[Ch4];//RBM = Right Back Moor
	motor[bottomLeft] = vexRT[Ch3] -vexRT[Ch1] -vexRT[Ch4];//LBM = Left Back Motor
}
